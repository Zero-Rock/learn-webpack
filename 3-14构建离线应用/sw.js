/* eslint-disable */
const serviceWorkerOption = {
  assets: [
    '/app.js',
    '/app.css',
    '/index.html',
  ],
};

/** *** */ (function (modules) { // webpackBootstrap
/** *** */ 	// The module cache
/** *** */ 	const installedModules = {};
  /** *** */
  /** *** */ 	// The require function
  /** *** */ 	function __webpack_require__(moduleId) {
    /** *** */
    /** *** */ 		// Check if module is in cache
    /** *** */ 		if (installedModules[moduleId]) {
      /** *** */ 			return installedModules[moduleId].exports;
      /** *** */ 		}
    /** *** */ 		// Create a new module (and put it into the cache)
    /** *** */ 		const module = installedModules[moduleId] = {
      /** *** */ 			i: moduleId,
      /** *** */ 			l: false,
      /** *** */ 			exports: {},
      /** *** */ 		};
    /** *** */
    /** *** */ 		// Execute the module function
    /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /** *** */
    /** *** */ 		// Flag the module as loaded
    /** *** */ 		module.l = true;
    /** *** */
    /** *** */ 		// Return the exports of the module
    /** *** */ 		return module.exports;
    /** *** */ 	}
  /** *** */
  /** *** */
  /** *** */ 	// expose the modules object (__webpack_modules__)
  /** *** */ 	__webpack_require__.m = modules;
  /** *** */
  /** *** */ 	// expose the module cache
  /** *** */ 	__webpack_require__.c = installedModules;
  /** *** */
  /** *** */ 	// define getter function for harmony exports
  /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
    /** *** */ 		if (!__webpack_require__.o(exports, name)) {
      /** *** */ 			Object.defineProperty(exports, name, {
        /** *** */ 				configurable: false,
        /** *** */ 				enumerable: true,
        /** *** */ 				get: getter,
        /** *** */ 			});
      /** *** */ 		}
    /** *** */ 	};
  /** *** */
  /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
  /** *** */ 	__webpack_require__.n = function (module) {
    /** *** */ 		const getter = module && module.__esModule ?
    /** *** */ 			function getDefault() { return module.default; } :
    /** *** */ 			function getModuleExports() { return module; };
    /** *** */ 		__webpack_require__.d(getter, 'a', getter);
    /** *** */ 		return getter;
    /** *** */ 	};
  /** *** */
  /** *** */ 	// Object.prototype.hasOwnProperty.call
  /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /** *** */
  /** *** */ 	// __webpack_public_path__
  /** *** */ 	__webpack_require__.p = '';
  /** *** */
  /** *** */ 	// Load entry module and return exports
  /** *** */ 	return __webpack_require__(__webpack_require__.s = 0);
/** *** */ }([
/* 0 */
/** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (global) { // 当前缓存版本的唯一标识符，用当前时间代替
      const cacheKey = new Date().toISOString();

      // 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key
      const cacheWhitelist = [cacheKey];

      // 需要被缓存的文件的 URL 列表
      const cacheFileList = global.serviceWorkerOption.assets;

      // 监听 install 事件
      self.addEventListener('install', (event) => {
        // 等待所有资源缓存完成时，才可以进行下一步
        event.waitUntil(
          caches.open(cacheKey).then((cache) => {
            // 要缓存的文件 URL 列表
            return cache.addAll(cacheFileList);
          })
        );
      });

      // 拦截网络请求
      self.addEventListener('fetch', (event) => {
        event.respondWith(
          // 去缓存中查询对应的请求
          caches.match(event.request).then((response) => {
            // 如果命中本地缓存，就直接返回本地的资源
            if (response) {
              return response;
            }
            // 否则就去用 fetch 下载资源
            return fetch(event.request);
          }
          )
        );
      });

      // 新 Service Workers 线程取得控制权后，将会触发其 activate 事件
      self.addEventListener('activate', (event) => {
        event.waitUntil(
          caches.keys().then((cacheNames) => {
            return Promise.all(
              cacheNames.map((cacheName) => {
                // 不在白名单的缓存全部清理掉
                if (cacheWhitelist.indexOf(cacheName) === -1) {
                  // 删除缓存
                  return caches.delete(cacheName);
                }
              })
            );
          })
        );
      });
      /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(1)));
    /** */ }),
  /* 1 */
  /** */ (function (module, exports) {
    let g;

    // This works in non-strict mode
    g = (function () {
      return this;
    }());

    try {
      // This works if eval is allowed (see CSP)
      g = g || Function('return this')() || (1, eval)('this');
    } catch (e) {
      // This works if the window reference is available
      if (typeof window === 'object') { g = window; }
    }

    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}

    module.exports = g;
    /** */ }),
/** *** */ ]));
